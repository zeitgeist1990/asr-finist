<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Финист - Ясный сокол </title>
  <link rel="icon" type="image/x-icon" href="logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet" />
  <style>
    :root {
      --primary-blue: #1e4e79;
      --primary-blue-light: #2a6ba3;
      --primary-orange: #f58320;
      --primary-orange-light: #ff9e4a;
      --gray-light: #f5f7f9;
      --gray-dark: #424242;
      --text-dark: #2c3e50;
      --text-light: #ffffff;
    }

    body {
      background: var(--gray-light);
      color: var(--text-dark);
      font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
    }

    body.drag-over {
      background-color: #e1e9f2 !important;
    }

    .tk-gradient-bg {
      background: linear-gradient(135deg, var(--primary-blue) 0%, var(--primary-blue-light) 100%);
    }

    .btn-primary {
      background: var(--primary-orange);
      color: var(--text-light);
      font-weight: 600;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      transition: all 0.2s ease;
    }

    .btn-primary:hover {
      background: var(--primary-orange-light);
      color: var(--text-light);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    .btn-outline-primary {
      background: transparent;
      color: var(--primary-blue);
      border: 2px solid var(--primary-blue);
      font-weight: 600;
    }

    .btn-outline-primary:hover {
      background: var(--primary-blue);
      color: var(--text-light);
    }

    .progress-bar {
      background: var(--primary-orange);
      color: var(--text-dark);
      font-weight: 600;
      border-radius: 100px;
    }

    .progress {
      height: 12px;
      border-radius: 100px;
      background-color: #e9ecef;
      overflow: hidden;
    }

    .card {
      border: none;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
    }

    .nav-tabs {
      border-bottom: 2px solid #e9ecef;
    }

    .nav-tabs .nav-link {
      border: none;
      padding: 0.75rem 1.25rem;
      font-weight: 600;
      color: var(--gray-dark);
      border-radius: 8px 8px 0 0;
    }

    .nav-tabs .nav-link.active {
      color: var(--primary-blue);
      background-color: transparent;
      border-bottom: 3px solid var(--primary-orange);
    }

    .nav-tabs .nav-link:hover {
      border-color: transparent;
      isolation: isolate;
    }

    #transcriptList li {
      animation: fadeIn 0.4s ease;
      border: none;
      border-left: 3px solid transparent;
      padding: 1rem 1.25rem;
      transition: all 0.2s ease;
    }

    #transcriptList li:hover {
      background-color: rgba(26, 110, 191, 0.1);
      border-left: 3px solid var(--primary-blue);
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: none; }
    }

    #overlay {
      background: rgba(30, 78, 121, 0.85);
      display: none;
      z-index: 1050;
    }

    #audioPlayerBox {
      display: none;
    }

    #overlay .message {
      text-align: center;
      font-size: 1.5rem;
      color: white;
    }

    .tk-badge {
      background: var(--primary-blue-light);
      color: var(--text-light);
      font-weight: 500;
      padding: 0.35rem 0.65rem;
      border-radius: 6px;
    }

    .tk-audio-player {
      border-radius: 8px;
      background: #f8f9fa;
      padding: 0.75rem;
    }

    .tk-waveform {
      border-radius: 8px;
      background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
    }

    .tk-time-display {
      font-family: 'Fira Mono', monospace;
      background: var(--primary-blue);
      color: var(--text-light);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.875rem;
    }

    .tk-alert-note {
      background-color: rgba(26, 110, 191, 0.1);
      border-left: 4px solid var(--primary-blue);
      color: var(--text-dark);
      border-radius: 4px;
    }

    .tk-header {
      padding: 1.5rem 0;
      border-bottom: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    }

    .tk-main-container {
      margin-top: 2rem;
    }

    .tk-section-title {
      font-weight: 700;
      margin-bottom: 1.25rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--primary-blue);
    }

    .tk-controls-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    @media (max-width: 992px) {
      .tk-controls-grid {
        grid-template-columns: 1fr;
      }
    }

    .tk-transcript-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .tk-transcript-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.25rem;
      padding-bottom: 0.75rem;
      border-bottom: 1px solid #e9ecef;
    }

    .tk-button-group {
      display: flex;
      gap: 0.5rem;
    }

    .tk-visualizer {
      position: relative;
      overflow: hidden;
      border-radius: 8px;
    }

    .tk-pulse {
      animation: tk-pulse 2s infinite;
    }

    @keyframes tk-pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
  </style>
</head>
<body>
  <!-- ============== ПРОЦЕСС ОБРАБОТКИ ============== -->
  <div id="overlay" class="position-fixed top-0 start-0 w-100 h-100 flex-column align-items-center justify-content-center text-white">
    <div class="spinner-border tk-pulse" role="status" id="overlaySpinner" style="width: 3rem; height: 3rem;"></div>
    <p class="mt-3 mb-0 fs-5 fw-medium" id="overlayText">Обработка...</p>
  </div>

  <!-- =================== ЗАГОЛОВОК =================== -->
  <header class="tk-header tk-gradient-bg">
    <div class="container">
      <div class="d-flex flex-column flex-md-row justify-content-between align-items-start align-items-md-center">
        <div class="d-flex align-items-center gap-3 mb-3 mb-md-0">
          <img src="logo.png" alt="логотип проекта" width="100" height="100" class="rounded shadow-sm" />
          <div>
            <h1 class="h3 fw-bold mb-1 text-white">Финист - ассистент диспетчера</h1>
            <p class="mb-0 text-white opacity-85">Мне важно найти правильные слова, самые точные, пусть и не самые красивые. Красивое слово часто обманывает, как обманчива любая красота.</p>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="container tk-main-container">
    <div class="row g-4">
      <!-- ЛЕВАЯ КОЛОНКА: Ввод / Управление -->
      <div class="col-lg-6">
        <div class="card p-4 h-100">
          <h2 class="tk-section-title">
            <i class="bi bi-input-cursor-text"></i>
            Источник аудио
          </h2>
          
          <ul class="nav nav-tabs mb-3" id="inputTab" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link active" id="upload-tab" data-bs-toggle="tab" data-bs-target="#uploadPane" type="button" role="tab" aria-controls="uploadPane" aria-selected="true">
                <i class="bi bi-cloud-upload me-2"></i>Загрузить аудио
              </button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="mic-tab" data-bs-toggle="tab" data-bs-target="#micPane" type="button" role="tab" aria-controls="micPane" aria-selected="false">
                <i class="bi bi-mic me-2"></i>Микрофон
              </button>
            </li>
          </ul>

          <div class="tab-content flex-grow-1" id="inputTabContent">
            <!-- Панель загрузки -->
            <div class="tab-pane fade show active" id="uploadPane" role="tabpanel">
              <div class="mb-4">
                <label for="fileInput" class="form-label fw-semibold">Выберите аудиофайл</label>
                <div class="border rounded p-4 text-center bg-light" id="dropZone">
                  <i class="bi bi-cloud-arrow-up display-4 text-secondary mb-3"></i>
                  <p class="mb-2">Перетащите аудиофайл сюда</p>
                  <p class="text-muted small mb-3">или</p>
                  <input id="fileInput" type="file" class="form-control d-none" accept="audio/*" />
                  <label for="fileInput" class="btn btn-outline-primary">Выбрать файл</label>
                  <div class="mt-2 text-muted small">Поддерживаемые форматы: WAV, MP3, OGG</div>
                </div>
              </div>

              <div id="audioPlayerBox" class="mb-4">
                <div class="tk-alert-note p-3 small">
                  <i class="bi bi-info-circle me-2"></i>
                  Аудио преобразовано в моно 16-битный PCM с частотой 8 кГц для соответствия входным требованиям системы распознавания.
                </div>
                <div class="tk-audio-player">
                  <audio id="audioPlayer" class="w-100" controls></audio>
                </div>
              </div>

              <button id="processBtn" class="btn btn-primary w-100 mb-4 py-3" disabled>
                <i class="bi bi-play-fill me-2"></i>Обработать аудио
              </button>

              <div class="mb-3">
                <div class="d-flex justify-content-between align-items-center mb-2">
                  <label class="form-label fw-semibold mb-0">Прогресс обработки</label>
                  <span id="progressPercent" class="tk-badge">0%</span>
                </div>
                <div class="progress" role="progressbar" aria-label="прогресс потока">
                  <div id="progressBar" class="progress-bar" style="width:0%"></div>
                </div>
              </div>
            </div>

            <!-- Панель микрофона -->
            <div class="tab-pane fade" id="micPane" role="tabpanel">
              <div class="tk-alert-note p-3 small mb-4">
                <i class="bi bi-info-circle me-2"></i>
                Распознавание выполняется пофразово. Сделайте короткую паузу, чтобы текст появился в списке.
              </div>

              <div class="tk-controls-grid mb-4">
                <button id="startRecBtn" class="btn btn-primary">
                  <i class="bi bi-record-circle me-2"></i>Начать запись
                </button>
                <button id="stopRecBtn" class="btn btn-outline-secondary" disabled>
                  <i class="bi bi-stop-circle me-2"></i>Остановить
                </button>
              </div>

              <div class="d-flex justify-content-center mb-3">
                <span id="timerDisplay" class="tk-time-display" style="display: none;">00:00:00</span>
              </div>

              <div class="tk-visualizer mb-4">
                <canvas id="micWaveform" class="tk-waveform w-100" width="500" height="120" style="display: none;"></canvas>
              </div>

              <div id="finalMicAudioContainer" class="mb-3" style="display: none;">
                <h3 class="h6 fw-semibold mb-2">Записанное аудио</h3>
                <div class="tk-audio-player">
                  <audio id="finalMicAudioPlayer" class="w-100" controls></audio>
                </div>
              </div>
              
              <div class="tk-audio-player" style="display: none;" id="segmentPlayerContainer">
                <h3 class="h6 fw-semibold mb-2">Выбранная фраза</h3>
                <audio id="segmentPlayer" class="w-100" controls></audio>
              </div>
              
              <div id="micLatencyAlert" class="alert alert-danger d-none small mt-3" role="alert"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- ПРАВАЯ КОЛОНКА: Транскрипция -->
      <div class="col-lg-6">
        <div class="card p-4 h-100">
          <div class="tk-transcript-container">
            <div class="tk-transcript-header">
              <h2 class="tk-section-title mb-0">
                <i class="bi bi-text-paragraph"></i>
                Транскрипция
              </h2>
              <div class="tk-button-group">
                <button id="copyBtn" class="btn btn-sm btn-outline-primary" title="Копировать JSON">
                  <i class="bi bi-clipboard"></i>
                </button>
                <button id="clearTranscriptBtn" class="btn btn-sm btn-outline-danger" title="Очистить транскрипцию">
                  <i class="bi bi-trash"></i>
                </button>
              </div>
            </div>
            
            <div class="position-relative flex-grow-1">
              <ul id="transcriptList" class="list-group list-group-flush overflow-auto" style="max-height: 55vh;"></ul>
              
              <div id="emptyState" class="text-center py-5" style="display: none;">
                <i class="bi bi-text-left display-4 text-muted mb-3"></i>
                <p class="text-muted">Обработайте аудиофайл или начните запись, чтобы увидеть транскрипцию здесь.</p>
              </div>
            </div>
            
            <div class="pt-3 mt-3 border-top">
              <div class="d-flex justify-content-between align-items-center">
                <small class="text-muted" id="transcriptStats">0 фраз</small>
                <small class="text-muted" id="audioDuration">Всего: 0.00с</small>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- СКРИПТЫ -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
  <script>
    // ========== Ссылки на DOM-элементы ==========
    const dom = {
      micWaveform: document.getElementById('micWaveform'),
      waveCtx: document.getElementById('micWaveform').getContext('2d'),
      timerDisplay: document.getElementById('timerDisplay'),
      segmentPlayer: document.getElementById('segmentPlayer'),
      segmentPlayerContainer: document.getElementById('segmentPlayerContainer'),
      finalMicAudioPlayer: document.getElementById('finalMicAudioPlayer'),
      finalMicAudioContainer: document.getElementById('finalMicAudioContainer'),
      fileInput: document.getElementById('fileInput'),
      dropZone: document.getElementById('dropZone'),
      processBtn: document.getElementById('processBtn'),
      startRecBtn: document.getElementById('startRecBtn'),
      stopRecBtn: document.getElementById('stopRecBtn'),
      progressBar: document.getElementById('progressBar'),
      progressPercent: document.getElementById('progressPercent'),
      transcriptList: document.getElementById('transcriptList'),
      audioPlayer: document.getElementById('audioPlayer'),
      audioPlayerBox: document.getElementById('audioPlayerBox'),
      overlay: document.getElementById('overlay'),
      overlayText: document.getElementById('overlayText'),
      overlaySpinner: document.getElementById('overlaySpinner'),
      copyBtn: document.getElementById('copyBtn'),
      clearTranscriptBtn: document.getElementById('clearTranscriptBtn'),
      micLatencyAlert: document.getElementById('micLatencyAlert'),
      emptyState: document.getElementById('emptyState'),
      transcriptStats: document.getElementById('transcriptStats'),
      audioDuration: document.getElementById('audioDuration')
    };

    // ========== Состояние ==========
    let waveAnimationFrame = null;
    let waveAudioData = new Float32Array(dom.micWaveform.width);
    let recordedChunks = [];
    let isRecordingChunks = false;

    let timerInterval = null;
    let startTime = null;

    let pcmBytes;
    let totalChunks = 0;
    let transcripts = [];

    let mediaStream = null;
    let audioCtx = null;
    let processor = null;
    let ws = null;
    let outstanding = 0;
    let backlogChk = null;

    // ========== Константы ==========
    const CHUNK_SAMPLES = 2400;
    const CHUNK_BYTES = CHUNK_SAMPLES * 2;
    const MAX_OUT = 3;
    const MAX_BACKLOG_SEC = 3;

    // ========== Вспомогательные функции UI ==========
    function setProgress(pct) {
      pct = Math.round(Math.max(0, Math.min(100, pct)));
      dom.progressBar.style.width = pct + '%';
      dom.progressPercent.textContent = pct + '%';
    }

    function showOverlay(message, showSpinner) {
      dom.overlayText.textContent = message;
      if (showSpinner) {
        dom.overlaySpinner.classList.remove('d-none');
      } else {
        dom.overlaySpinner.classList.add('d-none');
      }
      dom.overlay.style.display = 'flex';
    }

    function hideOverlay() {
      dom.overlay.style.display = 'none';
    }

    function resetUI() {
      setProgress(0);
      if (dom.finalMicAudioPlayer.src) {
        URL.revokeObjectURL(dom.finalMicAudioPlayer.src);
        dom.finalMicAudioPlayer.src = '';
      }
      if (dom.segmentPlayer.src) {
        URL.revokeObjectURL(dom.segmentPlayer.src);
        dom.segmentPlayer.src = '';
      }
      transcripts = [];
      dom.transcriptList.innerHTML = '';
      updateTranscriptStats();
      if (dom.audioPlayer) {
        dom.audioPlayer.src = '';
        dom.audioPlayerBox.style.display = 'none';
      }
      dom.processBtn.disabled = true;
      dom.micLatencyAlert.classList.add('d-none');
      if (ws && ws.readyState === WebSocket.OPEN) ws.close();

      if (dom.segmentPlayerContainer) {
        dom.segmentPlayer.pause();
        dom.segmentPlayer.src = '';
        dom.segmentPlayerContainer.style.display = 'none';
      }
    }

    function updateTranscriptStats() {
      dom.transcriptStats.textContent = `${transcripts.length} фраз${transcripts.length % 10 == 1 && transcripts.length % 100 != 11 ? 'а' : (transcripts.length % 10 >= 2 && transcripts.length % 10 <= 4 && (transcripts.length % 100 < 10 || transcripts.length % 100 >= 20) ? 'ы' : '')}`;
      
      if (transcripts.length === 0) {
        dom.emptyState.style.display = 'block';
        dom.audioDuration.textContent = 'Всего: 0.00с';
      } else {
        dom.emptyState.style.display = 'none';
        const totalDuration = transcripts[transcripts.length - 1].end_time;
        dom.audioDuration.textContent = `Всего: ${totalDuration.toFixed(2)}с`;
      }
    }

    // ========== WebSocket ==========
    function initWebSocket() {
      ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/api/ws');
      ws.binaryType = 'arraybuffer';
      outstanding = 0;

      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.event === 'ready') {
            outstanding = Math.max(outstanding - 1, 0);
          } else if (msg.event === 'transcript') {
            appendTranscript(msg.phrase);
          }
        } catch (err) {
          console.error('Ошибка JSON', err);
        }
      };
      ws.onerror = (e) => console.error('Ошибка WebSocket', e);
      ws.onclose = () => console.log('WebSocket закрыт');
    }

    // ========== Вспомогательные функции для аудио ==========
    function floatToPCM16(floatBuf) {
      const pcm = new Int16Array(floatBuf.length);
      for (let i = 0; i < floatBuf.length; i++) {
        const s = Math.max(-1, Math.min(1, floatBuf[i]));
        pcm[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return pcm;
    }

    function pcmToWav(pcmBytes, sampleRate) {
      const header = new ArrayBuffer(44);
      const dv = new DataView(header);
      const write = (o, s) => { for (let i = 0; i < s.length; i++) dv.setUint8(o + i, s.charCodeAt(i)); };
      write(0, 'RIFF'); dv.setUint32(4, 36 + pcmBytes.length, true);
      write(8, 'WAVEfmt '); dv.setUint32(16, 16, true); dv.setUint16(20, 1, true); dv.setUint16(22, 1, true);
      dv.setUint32(24, sampleRate, true); dv.setUint32(28, sampleRate * 2, true); dv.setUint16(32, 2, true); dv.setUint16(34, 16, true);
      write(36, 'data'); dv.setUint32(40, pcmBytes.length, true);
      return new Blob([header, pcmBytes], { type: 'audio/wav' });
    }

    function createAudioBlobFromChunks(chunks, startTime, endTime) {
      const sampleRate = 8000;
      const startSample = Math.floor(startTime * sampleRate);
      const endSample = Math.floor(endTime * sampleRate);
      let totalSamples = 0, chunkIndex = 0;
      while (chunkIndex < chunks.length && totalSamples + chunks[chunkIndex].length <= startSample) {
        totalSamples += chunks[chunkIndex].length;
        chunkIndex++;
      }

      let result = [], currentSample = startSample;
      while (chunkIndex < chunks.length && currentSample < endSample) {
        const chunk = chunks[chunkIndex++];
        const available = chunk.length;
        const needed = endSample - currentSample;
        result.push(chunk.slice(0, Math.min(available, needed)));
        currentSample += Math.min(available, needed);
      }

      const totalLength = result.reduce((sum, arr) => sum + arr.length, 0);
      const interleaved = new Float32Array(totalLength);
      let offset = 0;
      for (let i = 0; i < result.length; i++) {
        interleaved.set(result[i], offset);
        offset += result[i].length;
      }

      const pcm = floatToPCM16(interleaved);
      return pcmToWav(new Uint8Array(pcm.buffer), sampleRate);
    }

    function playSegment(url) {
      dom.segmentPlayer.src = url;
      dom.segmentPlayerContainer.style.display = 'block';
      dom.segmentPlayer.play();
    }

    // ========== Визуализатор волны ==========
    function drawWaveform() {
      waveAnimationFrame = requestAnimationFrame(drawWaveform);
      dom.waveCtx.clearRect(0, 0, dom.micWaveform.width, dom.micWaveform.height);
      
      // Рисуем градиентный фон
      const gradient = dom.waveCtx.createLinearGradient(0, 0, 0, dom.micWaveform.height);
      gradient.addColorStop(0, '#e3f2fd');
      gradient.addColorStop(1, '#bbdefb');
      dom.waveCtx.fillStyle = gradient;
      dom.waveCtx.fillRect(0, 0, dom.micWaveform.width, dom.micWaveform.height);
      
      // Рисуем центральную линию
      const centerY = dom.micWaveform.height / 2;
      dom.waveCtx.beginPath();
      dom.waveCtx.strokeStyle = '#90caf9';
      dom.waveCtx.lineWidth = 1;
      dom.waveCtx.moveTo(0, centerY);
      dom.waveCtx.lineTo(dom.micWaveform.width, centerY);
      dom.waveCtx.stroke();
      
      // Рисуем волну
      const step = Math.floor(waveAudioData.length / dom.micWaveform.width);
      dom.waveCtx.beginPath();
      dom.waveCtx.strokeStyle = '#1976d2';
      dom.waveCtx.lineWidth = 2;
      dom.waveCtx.lineJoin = 'round';
      
      for (let i = 0; i < dom.micWaveform.width; i++) {
        const index = i * step;
        const y = centerY + waveAudioData[index] * centerY * 0.8;
        if (i === 0) {
          dom.waveCtx.moveTo(i, y);
        } else {
          dom.waveCtx.lineTo(i, y);
        }
      }
      dom.waveCtx.stroke();
    }

    function updateWaveformData(data) {
      // Сдвигаем существующие данные влево
      for (let i = 0; i < waveAudioData.length - data.length; i++) {
        waveAudioData[i] = waveAudioData[i + data.length];
      }
      
      // Добавляем новые данные в конец
      for (let i = 0; i < data.length; i++) {
        const pos = waveAudioData.length - data.length + i;
        if (pos < waveAudioData.length) {
          waveAudioData[pos] = Math.max(-1, Math.min(1, data[i] || 0));
        }
      }
    }

    // ========== Транскрипция ==========
    function appendTranscript(obj) {
      transcripts.push(obj);
      const { text, start_time, end_time } = obj;
      const li = document.createElement('li');
      li.className = 'list-group-item d-flex justify-content-between align-items-start';
      const audioBlob = createAudioBlobFromChunks(recordedChunks, start_time, end_time);
      const audioUrl = URL.createObjectURL(audioBlob);
      li.innerHTML = `
        <div class="me-auto">
          <div class="fw-medium mb-1">${text}</div>
          <small class="text-muted">${start_time.toFixed(2)} – ${end_time.toFixed(2)}с</small>
        </div>
        <button class="btn btn-sm btn-outline-primary" onclick="playSegment('${audioUrl}')">
          <i class="bi bi-play-fill"></i>
        </button>
      `;
      dom.transcriptList.appendChild(li);
      li.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      updateTranscriptStats();
    }

    // ========== Загрузка файла ==========
    dom.dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dom.dropZone.style.backgroundColor = '#e9ecef';
    });

    dom.dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dom.dropZone.style.backgroundColor = '';
    });

    dom.dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dom.dropZone.style.backgroundColor = '';
      
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('audio/')) {
        const uploadTab = new bootstrap.Tab(document.getElementById('upload-tab'));
        uploadTab.show();

        resetUI();
        dom.fileInput.files = e.dataTransfer.files;
        const event = new Event('change', { bubbles: true });
        dom.fileInput.dispatchEvent(event);
      }
    });

    dom.fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      resetUI();
      showOverlay('Декодирование и ресемплирование до 8 кГц...', true);
      try {
        pcmBytes = await resampleToPCM(file, 8000);
        totalChunks = Math.ceil(pcmBytes.length / CHUNK_BYTES);
        const wavBlob = pcmToWav(pcmBytes, 8000);
        dom.audioPlayer.src = URL.createObjectURL(wavBlob);
        dom.audioPlayerBox.style.display = 'block';
        dom.processBtn.disabled = false;
      } catch (err) {
        alert('Не удалось декодировать или ресемплировать файл: ' + err.message);
        console.error(err);
      } finally {
        hideOverlay();
      }
    });

    dom.processBtn.addEventListener('click', () => startStreamingUpload());

    // ========== Микрофон ==========
    dom.startRecBtn.addEventListener('click', startMicCapture);
    dom.stopRecBtn.addEventListener('click', () => stopMicCapture());

    // ========== События ==========
    dom.clearTranscriptBtn.addEventListener('click', () => {
      dom.transcriptList.innerHTML = '';
      transcripts = [];
      updateTranscriptStats();
      dom.segmentPlayer.pause();
      dom.segmentPlayer.src = '';
      dom.segmentPlayerContainer.style.display = 'none';
    });

    dom.copyBtn.addEventListener('click', () => {
      if (transcripts.length === 0) {
        alert('Нет данных для копирования. Сначала обработайте аудио или начните запись.');
        return;
      }

      const jsonStr = JSON.stringify(transcripts, null, 2);
      navigator.clipboard.writeText(jsonStr).then(() => {
        dom.copyBtn.innerHTML = '<i class="bi bi-check-lg"></i>';
        dom.copyBtn.classList.remove('btn-outline-primary');
        dom.copyBtn.classList.add('btn-success');

        setTimeout(() => {
          dom.copyBtn.innerHTML = '<i class="bi bi-clipboard"></i>';
          dom.copyBtn.classList.remove('btn-success');
          dom.copyBtn.classList.add('btn-outline-primary');
        }, 1500);
      }).catch(err => {
        console.error('Ошибка копирования в буфер обмена:', err);
        alert('Не удалось скопировать данные в буфер обмена.');
      });
    });

    // ========== Вспомогательные функции ==========
    async function resampleToPCM(file, targetRate) {
      const arrayBuffer = await file.arrayBuffer();
      const ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: targetRate });
      const decoded = await ctx.decodeAudioData(arrayBuffer);
      await ctx.close();

      const { numberOfChannels, length } = decoded;
      const mono = new Float32Array(length);
      for (let ch = 0; ch < numberOfChannels; ch++) {
        const data = decoded.getChannelData(ch);
        for (let i = 0; i < length; i++) mono[i] += data[i];
      }
      const inv = 1 / numberOfChannels;
      for (let i = 0; i < length; i++) mono[i] *= inv;

      const pcm16 = floatToPCM16(mono);
      return new Uint8Array(pcm16.buffer);
    }

    function startStreamingUpload() {
      if (!pcmBytes) return;
      dom.processBtn.disabled = true;
      setProgress(0);
      transcripts = [];
      dom.transcriptList.innerHTML = '';
      recordedChunks = [];
      updateTranscriptStats();

      const intPCM = new Int16Array(pcmBytes.buffer);
      const floatPCM = new Float32Array(intPCM.length);
      for (let i = 0; i < intPCM.length; i++) {
        floatPCM[i] = intPCM[i] / 32768.0;
      }

      for (let i = 0; i < floatPCM.length; i += CHUNK_SAMPLES) {
        recordedChunks.push(floatPCM.slice(i, i + CHUNK_SAMPLES));
      }

      ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/api/ws');
      ws.binaryType = 'arraybuffer';

      let offset = 0, sent = 0, outstanding = 1;
      const pushCompleted = { val: false };

      const pushChunks = () => {
        if (pushCompleted.val) return;
        while (outstanding < MAX_OUT) {
          if (offset >= pcmBytes.length) {
            pushCompleted.val = true;
            ws.send(new Uint8Array());
            break;
          }
          ws.send(pcmBytes.slice(offset, offset + CHUNK_BYTES));
          offset += CHUNK_BYTES;
          sent++;
          outstanding++;
          setProgress((sent / totalChunks) * 100);
        }
      };

      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.event === 'ready') {
            outstanding = Math.max(outstanding - 1, 0);
            pushChunks();
          } else if (msg.event === 'transcript') {
            appendTranscript(msg.phrase);
          }
        } catch (err) {
          console.error('Ошибка JSON', err);
        }
      };

      ws.onclose = () => {
        dom.processBtn.disabled = false;
        setProgress(100);
      };

      ws.onerror = (e) => console.error('Ошибка WebSocket', e);

      ws.onopen = () => pushChunks();
    }

    async function startMicCapture() {
      resetUI();
      recordedChunks = [];
      isRecordingChunks = true;

      dom.micWaveform.style.display = 'block';
      if (waveAnimationFrame) cancelAnimationFrame(waveAnimationFrame);
      drawWaveform();

      dom.timerDisplay.style.display = 'inline-block';
      startTime = Date.now();

      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const hours = String(Math.floor(elapsed / 3600)).padStart(2, '0');
        const minutes = String(Math.floor((elapsed % 3600) / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        dom.timerDisplay.textContent = `${hours}:${minutes}:${seconds}`;
      }, 1000);

      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true }, video: false });
        audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 8000 });
        const input = audioCtx.createMediaStreamSource(mediaStream);
        processor = (audioCtx.createScriptProcessor || audioCtx.createJavaScriptNode).call(audioCtx, 1024, 1, 1);
        input.connect(processor);
        processor.connect(audioCtx.destination);

        initWebSocket();

        let buffer8k = [];
        processor.onaudioprocess = (ev) => {
          const data = ev.inputBuffer.getChannelData(0);
          buffer8k.push(...data);
          if (isRecordingChunks) recordedChunks.push(new Float32Array(data));
          updateWaveformData(data);

          while (buffer8k.length >= CHUNK_SAMPLES) {
            const chunk = buffer8k.slice(0, CHUNK_SAMPLES);
            buffer8k = buffer8k.slice(CHUNK_SAMPLES);
            const pcm16 = floatToPCM16(chunk);
            ws.send(new Uint8Array(pcm16.buffer));
            outstanding++;
          }
        };

        dom.startRecBtn.disabled = true;
        dom.stopRecBtn.disabled = false;

        backlogChk = setInterval(() => {
          const lagSec = outstanding * 0.3;
          if (lagSec > MAX_BACKLOG_SEC) {
            stopMicCapture(`Сервер отстает от реального времени более чем на ${MAX_BACKLOG_SEC} секунд.`);
          }
        }, 1000);
      } catch (err) {
        alert('Не удалось получить доступ к микрофону: ' + err.message);
        console.error(err);
      }
    }

    function stopMicCapture(reason = '') {
      if (dom.finalMicAudioPlayer.src) {
        URL.revokeObjectURL(dom.finalMicAudioPlayer.src);
        dom.finalMicAudioPlayer.src = '';
      }
      if (dom.segmentPlayer.src) {
        URL.revokeObjectURL(dom.segmentPlayer.src);
        dom.segmentPlayer.src = '';
      }
      if (processor) {
        processor.disconnect();
        processor.onaudioprocess = null;
        processor = null;
      }
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
      }
      if (backlogChk) {
        clearInterval(backlogChk);
        backlogChk = null;
      }
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(new Uint8Array());
      }

      dom.startRecBtn.disabled = false;
      dom.stopRecBtn.disabled = true;
      setProgress(0);

      if (reason) {
        dom.micLatencyAlert.textContent = reason;
        dom.micLatencyAlert.classList.remove('d-none');
      }

      isRecordingChunks = false;
      dom.micWaveform.style.display = 'none';

      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      dom.timerDisplay.textContent = '00:00:00';
      dom.timerDisplay.style.display = 'none';

      if (waveAnimationFrame) {
        cancelAnimationFrame(waveAnimationFrame);
        waveAnimationFrame = null;
      }
      dom.waveCtx.clearRect(0, 0, dom.micWaveform.width, dom.micWaveform.height);

      if (dom.segmentPlayerContainer) {
        dom.segmentPlayer.pause();
        dom.segmentPlayer.src = '';
        dom.segmentPlayerContainer.style.display = 'none';
      }

      if (recordedChunks.length > 0) {
        const totalLength = recordedChunks.reduce((sum, arr) => sum + arr.length, 0);
        const fullRecording = new Float32Array(totalLength);
        let offset = 0;
        for (let i = 0; i < recordedChunks.length; i++) {
          fullRecording.set(recordedChunks[i], offset);
          offset += recordedChunks[i].length;
        }

        const pcm = floatToPCM16(fullRecording);
        const wavBlob = pcmToWav(new Uint8Array(pcm.buffer), 8000);
        const wavUrl = URL.createObjectURL(wavBlob);

        dom.finalMicAudioPlayer.src = wavUrl;
        dom.finalMicAudioContainer.style.display = 'block';
      }
    }

    // ========== Очистка при переключении вкладок ==========
    const inputTab = document.getElementById('inputTab');
    inputTab.addEventListener('hide.bs.tab', () => {
      resetUI();
      if (dom.segmentPlayerContainer) {
        dom.segmentPlayer.pause();
        dom.segmentPlayer.src = '';
        dom.segmentPlayerContainer.style.display = 'none';
      }
    });

    // Инициализация пустого состояния
    updateTranscriptStats();
  </script>
</body>
</html>